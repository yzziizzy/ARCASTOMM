<html>
<head>
<style>
	.controls {
		height: 100px;
	}
	
	.chain .link {
		float: left;
		width: 100px;
		height: 100px;
		border: 1px solid black;
		padding: 5px;
		margin: 10px;
		position: relative;
	}
	.chain .link .option {
		color: gray;
		font-size: .9em;
		font-family: Sans Serif;
	}
	
	.output {
		clear: both;
	}


</style>

<script type="text/javascript">
	function $(sel, n) {
		return (n || document).querySelector(sel);
	}
	function $all(sel, n) {
		return (n || document).querySelectorAll(sel);
	}

	function $ev(sel, evs, cb) {
		var a = evs.split(' ');
		for(var ev of a) {
			var ns = document.querySelectorAll(sel);
			for(var n of ns) n.addEventListener(ev, cb);
		}
	}
	function $selectVal(sel, n) {
		var s = (n || document).querySelector(sel);
		return s && s.selectedOptions && s.selectedOptions[0] && s.selectedOptions[0].value || null;
	}
	function $show(sel, n) {
		var a = (n || document).querySelectorAll(sel);
		for(var i = 0; i < a.length; i++) {
			a[i].style.display = 'block';
		}
	}

	function $hide(sel, n) {
		var a = (n || document).querySelectorAll(sel);
		for(var i = 0; i < a.length; i++) {
			a[i].style.display = 'none';
		}
	}
	
	function mkElem(name, classes, contents) {
		var e = document.createElement(name);
		if(classes instanceof Array) {
			e.classes = classes;
		}
		else e.className = classes;
		
		e.innerHTML = contents;
		
		return e;
	}
	
	window.addEventListener('load', function() {
		
		$ev('.controls .transform-type', 'change', function(e) {
			var val = e.target.selectedOptions[0].value;
			
			if(val == '') return;
			
			$hide('.controls .transform-option');
			$show('.controls .'+val+'-options');
			
		})
		
		
		$ev('.controls button[name="add"]', 'click', function(e) { // todo: debounce
			var transf = $selectVal('.controls .transform-type');
			
			if(transf == '') return; // todo: error message
			
			var options = grabOptions('.controls .'+transf+'-options')
			options.transform = transf;
			
			addTransform(-1, options);
			
			$hide('.controls .transform-option');
			// TODO: reset values
			$('.controls .transform-type').selectedOption = 0;
		})
		
		addTransform(-1, {transform: 'rotAxis', X: 4, Y:5, Z: 6, Theta: 2});
		addTransform(-1, {transform: 'rotAxis', X: 7, Y:2, Z: 9, Theta: 1});
		
		$ev('.output button[name="solve"]', 'click', function(e) { // todo: debounce
			if(chain.length == 0) return;
			var cont = $('.output .results');
			
			var mchain = null; 
			
			for(var c of chain) {
				var e = mkElem('div', 'matrix', '');
				
				var mat = getTransformMatrix(c);
				
				var mod1, mod2;
				for(var i = 0; i < 100; i++) {
					[mod1, mat] = optimize_op(mat, constant_fold);
					if(mod1) {
						continue;
					}
					else {
						console.log("optimization rounds: " + (i + 1));
						break;
					}
				}
// 				var mat = getTransformMatrix(c);
				
				if(mchain === null) {
					mchain = mat;
				}
				else {
					mchain = {op: 'mul', arg1: mat, arg2: mchain };
				}
				
// 				e.innerHTML = printXP(txtPrintFns, mat);
				
// 				cont.appendChild(e);
			}
			
			
			cont.innerHTML = printXP(txtPrintFns, mchain);
			
			mchain = fullyOptimize(mchain, [constant_fold]);
			mchain = fullyOptimize(mchain, [distribute_terms]);
			mchain = fullyOptimize(mchain, [constant_fold]);
			mchain = fullyOptimize(mchain, [distribute_terms]);
			mchain = fullyOptimize(mchain, [constant_fold]);
			
			console.log(mchain);
			
			cont.innerHTML = printXP(txtPrintFns, mchain);
			
		});
	});
	
	function fullyOptimize(input, fns) {
		
		var mod;
		for(var i = 0; i < 100; i++) {
			var m = false;
			for(var fn of fns) {
				[mod, input] = optimize_op(input, fn);
				m = m || mod;
			}
			
			if(m) {
				continue;
			}
			else {
// 				console.log("optimization rounds: " + (i + 1));
				break;
			}
		}
		
		return input;
	}
	
	
	function grabOptions(sel) {
		var cont = $all(sel + ' input');
		var o = {};
		
		for(var opt of cont) {
			o[opt.name] = parseFloat(opt.value);
		}
		
		return o;
	}
	
	var chain = [];
	
	function addTransform(index, options) {
		if(index == -1) {
			chain.push(options);
		}
		else {
			chain.splice(index, 0, options);
		}
		renderChain($('.chain'), chain);
	}
	

	
	function renderChain(target, chain) {
		target.innerHTML = '';
		
		for(var c of chain) {
			var d = document.createElement('div');
			d.className = 'link';
			
			var name = document.createElement('div');
			name.className = 'name';
			name.innerHTML = c.transform;
			d.appendChild(name);
			
			if(c.X) {
				d.appendChild(mkElem('div', 'option', '[' + c.X + ', ' + c.Y + ', ' + c.Z + ']'));
			}
			if(c.Theta) {
				d.appendChild(mkElem('div', 'option', 'Theta: ' + c.Theta));
			}
			
			
			target.appendChild(d);
		} 
	}
	
	function is_op(xp, op) {
		return (typeof(xp) == 'object' && xp.op == op);
	}
	
	var txtPrintFns = {
		cos: function(fns, xp) { return 'cos(' + printXP(fns, xp.arg1) + ')'; },
		sin: function(fns, xp) { return 'sin(' + printXP(fns, xp.arg1) + ')'; },
		neg: function(fns, xp) { return '-' + printXP(fns, xp.arg1); },
		mul: function(fns, xp) { 
			if(is_op(xp.arg1, 'add') && is_op(xp.arg2, 'add')) {
				return printXP(fns, xp.arg1) + printXP(fns, xp.arg2);
			}
			if((is_num(xp.arg1) || is_builtin(xp.arg1)) && is_op(xp.arg2, 'add')) {
				return printXP(fns, xp.arg1) + printXP(fns, xp.arg2);
			}
			if((is_num(xp.arg2) || is_builtin(xp.arg2)) && is_op(xp.arg1, 'add')) {
				return printXP(fns, xp.arg2) + printXP(fns, xp.arg1);
			}
			
			return printXP(fns, xp.arg1) + ' * ' + printXP(fns, xp.arg2); 
		},
		add: function(fns, xp) { 
 			if(is_op(xp.arg2, 'neg')) {
				return '(' + printXP(fns, xp.arg1) + ' - ' + printXP(fns, xp.arg2.arg1) + ')'; 
			}
			else {
				return '(' + printXP(fns, xp.arg1) + ' + ' + printXP(fns, xp.arg2) + ')'; 
			}
		},
		mat: function(fns, xp) {
			var acc = '[';
			for(var a = 0; a < 4; a++) {
				acc += '[';
				for(var b = 0; b < 4; b++) {
					acc += printXP(fns, xp.arg1[a][b]) + (b < 3 ? ', ' : '');
				}
				acc += ']';
			}
			acc += ']';
			return acc;
		},
		term: function(fns, xp) {
			var acc = '' + (xp.arg1 == 1 ? '' : xp.arg1);
			
			for(var c of xp.arg2) {
				acc += printXP(fns, c);
			}
			acc += '';
			return acc;
		}
	}
	
	
	function printXP(fns, xp) {
		if(typeof(xp) == 'object') return fns[xp.op](fns, xp);
		else return xp;
	}
	
	
	function is_negative(xp) {
		if(typeof(xp) == 'object') {
			if(xp.op == 'neg') {
				return !is_negative(xp.arg1);
			}
			
			return false;
		}
		
		var v = parseFloat(v);
		return v < 0;
	}
	
	function identMatrix() {
		return {op: 'mat', arg1: [
			[1, 0, 0, 0],
			[0, 1, 0, 0],
			[0, 0, 1, 0],
			[0, 0, 0, 1],
		]};
	}
	
	function cos(x) { return {op: 'cos', arg1: x}; };
	function sin(x) { return {op: 'sin', arg1: x}; };
	function neg(x) { return {op: 'neg', arg1: x}; };
	function mul(x, y) { return {op: 'mul', arg1: x, arg2: y}; };
	function add(x, y) { 
// 		if(x instanceof Array) return {op: 'add', arg1ist: x};
		return {op: 'add', arg1: x, arg2: y}; 
	};
	function oneminus(x) { 
		return add(1, neg(x));
	};
	function sq(x) { 
		return mul(x, x);
	};
	
	function getTransformMatrix(xfm) {
		if(xfm.transform == 'rotX') {
			return {op: 'mat', arg1: [
				[1, 0,              0,                   0],
				[0, cos(xfm.Theta), neg(sin(xfm.Theta)), 0],
				[0, sin(xfm.Theta),     cos(xfm.Theta),  0],
				[0, 0,              0,                   1],
			]};
		}
		else if(xfm.transform == 'rotY') {
			return {op: 'mat', arg1: [
				[cos(xfm.Theta),      0, sin(xfm.Theta), 0],
				[0,                   1, 0,              0],
				[neg(sin(xfm.Theta)), 0, cos(xfm.Theta), 0],
				[0,                   0, 0,              1],
			]};
		}
		else if(xfm.transform == 'rotZ') {
			return {op: 'mat', arg1: [
				[cos(xfm.Theta), neg(sin(xfm.Theta)), 0, 0],
				[sin(xfm.Theta), cos(xfm.Theta),      0, 0],
				[0,              0,                   1, 0],
				[0,              0,                   0, 1],
			]};
		}
		else if(xfm.transform == 'rotZ') {
			return {op: 'mat', arg1: [
				[cos(xfm.Theta), neg(sin(xfm.Theta)), 0, 0],
				[sin(xfm.Theta), cos(xfm.Theta),      0, 0],
				[0,              0,                   1, 0],
				[0,              0,                   0, 1],
			]};
		}
		else if(xfm.transform == 'scale') {
			return {op: 'mat', arg1: [
				[xfm.X, 0,     0,     0],
				[0,     xfm.Y, 0,     0],
				[0,     0,     xfm.Z, 0],
				[0,     0,     0,     1],
			]};
		}
		else if(xfm.transform == 'translate') {
			return {op: 'mat', arg1: [
				[1, 0, 0, xfm.X],
				[0, 1, 0, xfm.Y],
				[0, 0, 1, xfm.Z],
				[0, 0, 0, 1],
			]};
		}
		else if(xfm.transform == 'rotAxis') {
			var c = cos(xfm.Theta);
			var s = sin(xfm.Theta);
			var omc = oneminus(cos(xfm.Theta));
			return {op: 'mat', arg1: [
				[
					add(mul(omc, mul(xfm.X, xfm.X)), c), 
					add(mul(omc, mul(xfm.X, xfm.Y)), mul(s, xfm.Z)),
					add(mul(omc, mul(xfm.X, xfm.Z)), mul(neg(s), xfm.Y)),
					0
				],
				[
					add(mul(omc, mul(xfm.Y, xfm.X)), mul(neg(s), xfm.Z)), 
					add(mul(omc, mul(xfm.Y, xfm.Y)), c), 
					add(mul(omc, mul(xfm.Y, xfm.Z)), mul(s, xfm.X)), 
					0
				],
				[
					add(mul(omc, mul(xfm.Z, xfm.X)), mul(s, xfm.Y)), 
					add(mul(omc, mul(xfm.Z, xfm.Y)), mul(neg(s), xfm.X)), 
					add(mul(omc, mul(xfm.Z, xfm.Z)), c), 
					0
				],
				[0, 0, 0, 1],
			]};
		}
		
	}
	
	function grow_term(a, b) {
		var t = {op: 'term', arg1: 1.0, arg2: [] };
		
		if(typeof a == 'object' && a.op == 'neg') {
			t.arg1 = !t.arg1;
			a = a.arg1;
		}
		if(typeof b == 'object' && b.op == 'neg') {
			t.arg1 = !t.arg1;
			b = b.arg1;
		}
		
// 		if(is_num(a)) {
// 			t.rat.t += t.rat.b * Math.abs(a);
// 			t.neg = t.neg ^ (a < 0);
// 		}
		if(is_num(a)) {
			t.arg1 *= Math.abs(a);
			t.neg ^= (a < 0);
		}
		if(is_num(b)) {
			t.arg1 *= Math.abs(b);
			t.neg ^= (b < 0);
		}
		
		
		if(is_builtin(a)) {
			// temp: addit straight in
			// todo: square duplicates
			t.arg2.push(a);
		}
		if(is_builtin(b)) {
			// temp: addit straight in
			// todo: square duplicates
			t.arg2.push(b);
		}
		
		if(is_op(a, 'term')) {
			t.arg1 *= a.arg1;
			t.arg2 = t.arg2.concat(a.arg2)
		}
		if(is_op(b, 'term')) {
			t.arg1 *= b.arg1;
			t.arg2 = t.arg2.concat(b.arg2)
		}
		
		
		if(is_op(a, 'add')) { // from a simple term
			t.arg2.push(a)
		}
		if(is_op(b, 'add')) { // from a simple term
			t.arg2.push(b)
		}
		

		
		return t;
	}
	
	function is_num(xp) {
		return typeof(xp) == 'number';
	}
	function is_builtin(xp) {
		if(typeof(xp) != 'object') return false;
		if(xp.op == 'cos' || xp.op == 'sin' || xp.op == 'neg') return true;
		return false;
	}
	function is_const(xp) {
		return is_num(xp) || (is_builtin(xp) && is_const(xp.arg1));
	}
	function is_simple_term(xp) {
		if(is_num(xp) || (is_builtin(xp) && is_const(xp.arg1))) return true;
		if(xp.op == 'add') {
			if(!(is_num(xp.arg1) || is_num(xp.arg2))) return false;
			if(!(is_builtin(xp.arg1) || is_builtin(xp.arg2))) return false;
			return true;
		}
	}
	function is_matrix(xp) {
		return typeof(xp) == 'object' && xp.op == 'mat';
	}
	
	function constant_fold(op, a1, a2, xp) {
		
		if(op == 'add') {
			if(a1 == 0) return a2;
			if(a2 == 0) return a1;
			if(is_num(a1) && is_num(a2)) {
				return a1 + a2;
			}
		}
		
		if(op == 'mul') {
			if(a1 == 1) return a2;
			if(a1 == -1) return neg(a2);
			if(a2 == 1) return a1;
			if(a2 == -1) return neg(a1);
			if(a1 == 0 || a2 == 0) { 
				return 0 
			}
			if(is_num(a1) && is_num(a2)) {
				return a1 * a2;
			}
			
			
			// not exactly constant folding below here
			
			if(is_matrix(a1) && is_matrix(a2)) {
				return mat_mul(a1, a2);
			}
			
			if(is_simple_term(a1) && is_simple_term(a2)) {
				return grow_term(a1, a2);
			}
			
			if(is_op(a1, 'term') && is_simple_term(a2)) {
				return grow_term(a1, a2);
			}
			if(is_simple_term(a1) && is_op(a2, 'term')) {
				return grow_term(a1, a2);
			}
			if(is_op(a1, 'term') && is_op(a2, 'term')) {
				return grow_term(a1, a2);
			}
		}
		
		if(op == 'term') {
			if(a1 == 0) return 0;
		}
		
		if(op == 'neg') {
			if(a1 == 0) return 0;
			if(is_num(a1)) {
				return -a1;
			}
		}
		
		if(op == 'cos') {
			if(a1 == 0) return 1;
			if(a1 == 'pi') return 0;
		}
		if(op == 'sin') {
			if(a1 == 'pi') return 1;
			if(a1 == 0) return 0;
		}
		
		return false;
	}
	
	function mat_mul(aa, bb) {
		var a = aa.arg1;
		var b = bb.arg1;
		var out = [[],[],[],[]];
		
		for(r = 0; r < 4; r++) {
			for(c = 0; c < 4; c++) {
				out[c][r] = add(add(
					mul(a[c][0], b[0][r]), 
					mul(a[c][1], b[1][r])), add( 
					mul(a[c][2], b[2][r]),
					mul(a[c][3], b[3][r])));
			}
		}
		
		return {op: 'mat', arg1: out};
	}
	
	// applies the distributive property of multiplication and addition widely
	function distribute_terms(op, a1, a2, xp) {
		if(op == 'mul') {
			if(is_op(a1, 'add') && is_op(a2, 'add')) {
				
				return add(
					add(mul(a1.arg1, a2.arg1), mul(a1.arg2, a2.arg2)),
					add(mul(a1.arg2, a2.arg1), mul(a1.arg2, a2.arg1))
				);
			}
			
			if(is_op(a1, 'add') && is_op(a2, 'term')) {
				
				return add(mul(a1.arg1, a2), mul(a1.arg2, a2));
			}
			
			if(is_op(a1, 'term') && is_op(a2, 'add')) {
				
				return add(mul(a2.arg1, a1), mul(a2.arg2, a1));
			}
		}
		
		return false;
	}
	
	function optimize_op(xp, fn) {
		if(typeof(xp) != 'object') {
			return [false, xp];
		}
		if(xp instanceof Array) {
			var m = false;
			var o = xp.map(function(x) { 
				var [m1, o1] = optimize_op(x, fn);
				m = m || m1;
				return o1;
			});
			return [m, o];
		}
		
		var modified = false;
		
		if(xp.op == 'mat') {
			var o = [];
			for(var a = 0; a < 4; a++) {
				o[a] = [];
				for(var b = 0; b < 4; b++) {
					var z = optimize_op(xp.arg1[a][b], fn);
					o[a][b] = z[1];
					
					modified = modified || z[0];
				}
			}
			return [modified, {op: 'mat', arg1: o}];
		}
		
		var [m1, a1] = optimize_op(xp.arg1, fn);
		var [m2, a2] = optimize_op(xp.arg2, fn);
		
		var out = fn(xp.op, a1, a2, xp);
		
		if(out === false) {
			
			return [m1 || m2, {op: xp.op, arg1: a1, arg2: a2}];
		}
		else return [true, out];
	}
	
	
	
</script>

</head>
<body>
	
	<div class="controls">
		<select class="transform-type">
			<option value="">-- Select Transformation --</option>
			<option value="rotX">Rotation about X</option>
			<option value="rotY">Rotation about Y</option>
			<option value="rotZ">Rotation about Z</option>
			<option value="rotAxis">Rotation about Axis</option>
			<option value="translate">Translation</option>
			<option value="scale">Scale</option>
		</select>
		
		<div class="rotX-options transform-option" style="display:none;">
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		<div class="rotY-options transform-option" style="display:none;">
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		<div class="rotZ-options transform-option" style="display:none;">
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		
		<div class="rotAxis-options transform-option" style="display:none;">
			<label>Axis X</label><input type="edit" name="X" value="0"></input>
			<label>Axis Y</label><input type="edit" name="Y" value="0"></input>
			<label>Axis Z</label><input type="edit" name="Z" value="0"></input>
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		
		<div class="translate-options transform-option" style="display:none;">
			<label>X</label><input type="edit" name="X" value="0"></input>
			<label>Y</label><input type="edit" name="Y" value="0"></input>
			<label>Z</label><input type="edit" name="Z" value="0"></input>
		</div>
		
		<div class="scale-options transform-option" style="display:none;">
			<label>X</label><input type="edit" name="X" value="0"></input>
			<label>Y</label><input type="edit" name="Y" value="0"></input>
			<label>Z</label><input type="edit" name="Z" value="0"></input>
		</div>
		
		<button name="add">Add</button>
		
	</div>
	
	<div class="chain">
		
		
	</div>
	
	<div class="output">
		<button name="solve">Solve</button>
		
		<div class="results"></div> 
		
	</div>
	
</body>
</html>

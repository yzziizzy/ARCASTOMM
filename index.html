<html>
<head>
<style>
	.controls {
		height: 100px;
	}
	
	.chain .link {
		float: left;
		width: 100px;
		height: 100px;
		border: 1px solid black;
		padding: 5px;
		margin: 10px;
		position: relative;
	}
	.chain .link .option {
		color: gray;
		font-size: .9em;
		font-family: Sans Serif;
	}
	
	.output {
		clear: both;
	}
	
	
	._add, ._mul, ._neg, ._term, ._sin, ._cos, ._ovar, ._uvar {
		display: inline-block;
		white-space: nowrap;
		padding: 2px;
	}
	
	._add { border: 2px solid purple; }
	._mul { border: 2px solid green; }
	._neg { border: 2px solid gray; }
	._term { border: 2px solid orange; }
	._sin { border: 2px solid pink; }
	._cos { border: 2px solid pink; }
	._ovar { border: 2px solid black; }
	._uvar { border: 2px solid silver; }


</style>

<script type="text/javascript">
	function $(sel, n) {
		return (n || document).querySelector(sel);
	}
	function $all(sel, n) {
		return (n || document).querySelectorAll(sel);
	}

	function $ev(sel, evs, cb) {
		var a = evs.split(' ');
		for(var ev of a) {
			var ns = document.querySelectorAll(sel);
			for(var n of ns) n.addEventListener(ev, cb);
		}
	}
	function $selectVal(sel, n) {
		var s = (n || document).querySelector(sel);
		return s && s.selectedOptions && s.selectedOptions[0] && s.selectedOptions[0].value || null;
	}
	function $show(sel, n) {
		var a = (n || document).querySelectorAll(sel);
		for(var i = 0; i < a.length; i++) {
			a[i].style.display = 'block';
		}
	}

	function $hide(sel, n) {
		var a = (n || document).querySelectorAll(sel);
		for(var i = 0; i < a.length; i++) {
			a[i].style.display = 'none';
		}
	}
	
	function mkElem(name, classes, contents) {
		var e = document.createElement(name);
		if(classes instanceof Array) {
			e.classes = classes;
		}
		else e.className = classes;
		
		e.innerHTML = contents;
		
		return e;
	}
	
	window.addEventListener('load', function() {
		
		$ev('.controls .transform-type', 'change', function(e) {
			var val = e.target.selectedOptions[0].value;
			
			if(val == '') return;
			
			$hide('.controls .transform-option');
			$show('.controls .'+val+'-options');
			
		})
		
		
		$ev('.controls button[name="add"]', 'click', function(e) { // todo: debounce
			var transf = $selectVal('.controls .transform-type');
			
			if(transf == '') return; // todo: error message
			
			var options = grabOptions('.controls .'+transf+'-options')
			options.transform = transf;
			
			addTransform(-1, options);
			
			$hide('.controls .transform-option');
			// TODO: reset values
			$('.controls .transform-type').selectedOption = 0;
		})
		
		addTransform(-1, {transform: 'rotAxis', X: 4, Y:5, Z: 6, Theta: 2});
		addTransform(-1, {transform: 'rotAxis', X: 7, Y:2, Z: 9, Theta: 1});
		addTransform(-1, {transform: 'scale', X: 7, Y:2, Z: 9});
		addTransform(-1, {transform: 'rotAxis', X: 3, Y:4, Z: 5, Theta: 6});
		
		$ev('.output button[name="solve"]', 'click', function(e) { // todo: debounce
			if(chain.length == 0) return;
			var cont = $('.output .results');
			
			var mchain = null; 
			
			for(var c of chain) {
				var e = mkElem('div', 'matrix', '');
				
				var mat = getTransformMatrix(c);
				
				var mod1, mod2;
				for(var i = 0; i < 100; i++) {
					[mod1, mat] = optimize_op(mat, constant_fold);
					if(mod1) {
						continue;
					}
					else {
						console.log("optimization rounds: " + (i + 1));
						break;
					}
				}
// 				var mat = getTransformMatrix(c);
				
				if(mchain === null) {
					mchain = mat;
				}
				else {
					mchain = mul(mat, mchain);
				}
				
// 				e.innerHTML = printXP(txtPrintFns, mat);
				
// 				cont.appendChild(e);
			}
			
			
// 			cont.innerHTML = printXP(txtPrintFns, mchain);
			
			mchain = fullyOptimize(mchain, [constant_fold, distribute_terms, combine_terms]);
// 			mchain = fullyOptimize(mchain, [distribute_terms]);
// 			mchain = fullyOptimize(mchain, [constant_fold]);
// 			mchain = fullyOptimize(mchain, [distribute_terms]);
// 			mchain = fullyOptimize(mchain, [constant_fold]);
// 			mchain = fullyOptimize(mchain, [distribute_terms]);
// 			mchain = fullyOptimize(mchain, [constant_fold]);
			
			var context = {
				xp: mchain,
				vardef: {},
				varalloc: {},
				varnum: 1,
			};
			
// 			factor_ovars(context);
// 			factor_ovars(context);
			
// 			context.xp = fullyOptimize(context.xp, [combine_terms]);
			
			cont.innerHTML = printXP(debugPrintFns, context.xp);
			
		});
	});
	
	function factor_ovars(context) {
		
		var term_pairs = [];
		var terms = {};
		
		function addTerms(list) {
			var key = list.sort().join(':');
			
		}
		
		
		walk_ops(context.xp, function(xp) {
			if(xp.op == 'term') {
				console.log('len', xp.arg2.length);
				for(t1 in xp.arg2) {
					for(var t2 = t1|0 + 1; t2 < xp.arg2.length; t2++) {
						
						var p = printXP(txtPrintFns, xp.arg2[t1]);
						var q = printXP(txtPrintFns, xp.arg2[t2]);
						var key = p+':'+q;
						terms[key] = [xp.arg2[t1], xp.arg2[t2]];
						term_pairs.push(key);
					}
				}
			}
			
		});
		
		
		
		
		var counts = {}
		
		term_pairs.map(function(x) {
			counts[x] = (counts[x]|0) + 1;
		});
		
		console.log('counts', counts);
		
		
		var varalloc = {};
		var vardef = {};
		var acounts = [];
		for(var k in counts) { 
			acounts.push([counts[k], k]); 
			var v = 'o'+(context.varnum++);
			context.varalloc[k] = v;
			context.vardef[v] = terms[k];
		}
		
		var aa = acounts.sort(function(a,b) { return b[0] - a[0] });
		
		console.log(aa);
		
		[xxx, context.xp] = optimize_op(context.xp, function(op, a1, a2) {
			if(op == 'term') {
				var out_arg2 = [];
			
				for(var t2 = 1; t2 < a2.length; t2++) {
					
					var p = printXP(txtPrintFns, a2[t2 - 1]);
					var q = printXP(txtPrintFns, a2[t2]);
					var key = p+':'+q;
					
					if(!context.varalloc[key]) {
						out_arg2.push(a2[t2 - 1]);
						continue;
					}
					
					out_arg2.push({op: 'ovar', arg1: context.varalloc[key]});
					t2++;
					
// 							terms[key] = [xp.arg2[t1], xp.arg2[t2]];
// 							term_pairs.push(key);
				}
				
				if(t2 <= a2.length) { // BUG: this may be borked
					out_arg2.push(a2[a2.length - 1]);
				}
				
				return {
					op: 'term',
					arg1: a1,
					arg2: out_arg2,
				}
			}
			
			return false;
		});
		
	}
	
	
	
	
	// runs a set of optimization functions until they all stabilize
	function fullyOptimize(input, fns) {
		
		var mod;
		for(var i = 0; i < 100; i++) {
			var m = false;
			for(var fn of fns) {
				[mod, input] = optimize_op(input, fn);
				m = m || mod;
			}
			
			if(m) {
				continue;
			}
			else {
// 				console.log("optimization rounds: " + (i + 1));
				break;
			}
		}
		
		return input;
	}
	
	
	function grabOptions(sel) {
		var cont = $all(sel + ' input');
		var o = {};
		
		for(var opt of cont) {
			if(parseFloat(opt.value) == opt.value) {
				o[opt.name] = parseFloat(opt.value);
			}
			else {
				o[opt.name] = uvar(opt.value);
			}
		}
		
		return o;
	}
	
	var chain = [];
	
	function addTransform(index, options) {
		if(index == -1) {
			chain.push(options);
		}
		else {
			chain.splice(index, 0, options);
		}
		renderChain($('.chain'), chain);
	}
	

	
	function renderChain(target, chain) {
		target.innerHTML = '';
		
		for(var c of chain) {
			var d = document.createElement('div');
			d.className = 'link';
			
			var name = document.createElement('div');
			name.className = 'name';
			name.innerHTML = c.transform;
			d.appendChild(name);
			
			if(c.X) {
				d.appendChild(mkElem('div', 'option', '[' + c.X + ', ' + c.Y + ', ' + c.Z + ']'));
			}
			if(c.Theta) {
				d.appendChild(mkElem('div', 'option', 'Theta: ' + c.Theta));
			}
			
			
			target.appendChild(d);
		} 
	}
	
	function is_op(xp, op) {
		return (typeof(xp) == 'object' && xp.op == op);
	}
	
	var txtPrintFns = {
		ovar: function(fns, xp) { return xp.arg1 + ''; },
		uvar: function(fns, xp) { return xp.arg1 + ''; },
		cos: function(fns, xp) { return 'cos(' + printXP(fns, xp.arg1) + ')'; },
		sin: function(fns, xp) { return 'sin(' + printXP(fns, xp.arg1) + ')'; },
		neg: function(fns, xp) { return '-' + printXP(fns, xp.arg1); },
		mul: function(fns, xp) { 
			
			return '' + 
				xp.arg1.map(function(x) { return printXP(fns, x); }).join(' * ') +
				'';
			
			if(is_op(xp.arg1, 'add') && is_op(xp.arg2, 'add')) {
				return printXP(fns, xp.arg1) + printXP(fns, xp.arg2);
			}
			if((is_num(xp.arg1) || is_builtin(xp.arg1)) && is_op(xp.arg2, 'add')) {
				return printXP(fns, xp.arg1) + printXP(fns, xp.arg2);
			}
			if((is_num(xp.arg2) || is_builtin(xp.arg2)) && is_op(xp.arg1, 'add')) {
				return printXP(fns, xp.arg2) + printXP(fns, xp.arg1);
			}
			
			return printXP(fns, xp.arg1) + ' * ' + printXP(fns, xp.arg2); 
		},
		add: function(fns, xp) { 
			
			return '(' + 
				xp.arg1.map(function(x) { return printXP(fns, x); }).join(' + ') +
				')';
			
 			if(is_op(xp.arg2, 'neg')) {
				return '(' + printXP(fns, xp.arg1) + ' - ' + printXP(fns, xp.arg2.arg1) + ')'; 
			}
			else {
				return '(' + printXP(fns, xp.arg1) + ' + ' + printXP(fns, xp.arg2) + ')'; 
			}
		},
		mat: function(fns, xp) {
			var acc = '[';
			for(var a = 0; a < 4; a++) {
				acc += '[';
				for(var b = 0; b < 4; b++) {
					acc += printXP(fns, xp.arg1[a][b]) + (b < 3 ? ', ' : '');
				}
				acc += ']';
			}
			acc += ']';
			return acc;
		},
		term: function(fns, xp) {
			var acc = '' + (xp.arg1 == 1 ? '' : xp.arg1);
			
			for(var c of xp.arg2) {
				acc += printXP(fns, c);
			}
			acc += '';
			return acc;
		}
	}
	
	var htmlPrintFns = {
		ovar: function(fns, xp) { return '<b>' + xp.arg1 + '</b>'; },
		uvar: function(fns, xp) { return '<b>' + xp.arg1 + '</b>'; },
		cos: function(fns, xp) { return '<i>cos</i>(' + printXP(fns, xp.arg1) + ')'; },
		sin: function(fns, xp) { return '<i>sin</i>(' + printXP(fns, xp.arg1) + ')'; },
		neg: function(fns, xp) { return '-' + printXP(fns, xp.arg1); },
		mul: function(fns, xp) { 
			
			return '' + 
				xp.arg1.map(function(x) { return printXP(fns, x); }).join(' * ') +
				'';
			
			if(is_op(xp.arg1, 'add') && is_op(xp.arg2, 'add')) {
				return printXP(fns, xp.arg1) + printXP(fns, xp.arg2);
			}
			if((is_num(xp.arg1) || is_builtin(xp.arg1)) && is_op(xp.arg2, 'add')) {
				return printXP(fns, xp.arg1) + printXP(fns, xp.arg2);
			}
			if((is_num(xp.arg2) || is_builtin(xp.arg2)) && is_op(xp.arg1, 'add')) {
				return printXP(fns, xp.arg2) + printXP(fns, xp.arg1);
			}
			
			return printXP(fns, xp.arg1) + ' * ' + printXP(fns, xp.arg2); 
		},
		add: function(fns, xp) { 
			
			return '(' + 
				xp.arg1.map(function(x) { return printXP(fns, x); }).join(' + ') +
				')';
			
 			if(is_op(xp.arg2, 'neg')) {
				return '(' + printXP(fns, xp.arg1) + ' - ' + printXP(fns, xp.arg2.arg1) + ')'; 
			}
			else {
				return '(' + printXP(fns, xp.arg1) + ' + ' + printXP(fns, xp.arg2) + ')'; 
			}
		},
		mat: function(fns, xp) {
			var acc = '<table class="matrix">';
			for(var a = 0; a < 4; a++) {
				acc += '<tr>';
				for(var b = 0; b < 4; b++) {
					acc += '<td>' + printXP(fns, xp.arg1[a][b]) + '</td>';
				}
				acc += '</tr>';
			}
			acc += '</table>';
			return acc;
		},
		term: function(fns, xp) {
			var acc = '' + (xp.arg1 == 1 ? '' : xp.arg1);
			
			for(var c of xp.arg2) {
				acc += printXP(fns, c);
			}
			acc += '';
			return acc;
		}
	}
	
	var debugPrintFns = {
		ovar: function(fns, xp) { return '<span class="_ovar">' + xp.arg1 + '</span>'; },
		uvar: function(fns, xp) { return '<<span class="_ovar">' + xp.arg1 + '</span>'; },
		cos: function(fns, xp) { return '<span class="_cos">cos(' + printXP(fns, xp.arg1) + ')</span>'; },
		sin: function(fns, xp) { return '<span class="_sin">sin(' + printXP(fns, xp.arg1) + ')</span>'; },
		neg: function(fns, xp) { return '<span class="_neg">-' + printXP(fns, xp.arg1) + '</span>'; },
		mul: function(fns, xp) { 
			
			return '<span class="_mul">' + 
				xp.arg1.map(function(x) { return printXP(fns, x); }).join(' * ') +
				'</span>';
			
			if(is_op(xp.arg1, 'add') && is_op(xp.arg2, 'add')) {
				return '<span class="_mul">' + printXP(fns, xp.arg1) + '</span>';
			}
			if((is_num(xp.arg1) || is_builtin(xp.arg1)) && is_op(xp.arg2, 'add')) {
				return '<span class="_mul">' + printXP(fns, xp.arg1) + '</span>';
			}
			if((is_num(xp.arg2) || is_builtin(xp.arg2)) && is_op(xp.arg1, 'add')) {
				return '<span class="_mul">' + printXP(fns, xp.arg2) + printXP(fns, xp.arg1) + '</span>';
			}
			
			return '<span class="_mul">' + printXP(fns, xp.arg1) + ' * ' + printXP(fns, xp.arg2); 
		},
		add: function(fns, xp) { 
			
			return '<span class="_add">(' + 
				xp.arg1.map(function(x) { return printXP(fns, x); }).join(' + ') +
				')</span>';
			
 			if(is_op(xp.arg2, 'neg')) {
				return '<span class="_add">(' + printXP(fns, xp.arg1) + ' - ' + printXP(fns, xp.arg2.arg1) + ')</span>'; 
			}
			else {
				return '<span class="_add">(' + printXP(fns, xp.arg1) + ' + ' + printXP(fns, xp.arg2) + ')</span>'; 
			}
		},
		mat: function(fns, xp) {
			var acc = '<table class="matrix _matrix">';
			for(var a = 0; a < 4; a++) {
				acc += '<tr>';
				for(var b = 0; b < 4; b++) {
					acc += '<td>' + printXP(fns, xp.arg1[a][b]) + '</td>';
				}
				acc += '</tr>';
			}
			acc += '</table>';
			return acc;
		},
		term: function(fns, xp) {
			var acc = '<span class="_term">' + (xp.arg1 == 1 ? '' : xp.arg1);
			
			for(var c of xp.arg2) {
				acc += printXP(fns, c);
			}
			acc += '</span>';
			return acc;
		}
	}
	
	
	function printXP(fns, xp) {
		if(typeof(xp) == 'object') return fns[xp.op](fns, xp);
		else return xp;
	}
	
	
	function is_negative(xp) {
		if(typeof(xp) == 'object') {
			if(xp.op == 'neg') {
				return !is_negative(xp.arg1);
			}
			
			return false;
		}
		
		var v = parseFloat(v);
		return v < 0;
	}
	
	function identMatrix() {
		return {op: 'mat', arg1: [
			[1, 0, 0, 0],
			[0, 1, 0, 0],
			[0, 0, 1, 0],
			[0, 0, 0, 1],
		]};
	}
	
	function ovar(x) { return {op: 'ovar', arg1: x}; };
	function uvar(x) { return {op: 'uvar', arg1: x}; };
	function cos(x) { return {op: 'cos', arg1: x}; };
	function sin(x) { return {op: 'sin', arg1: x}; };
	function neg(x) { return {op: 'neg', arg1: x}; };
	function mul(x, y) { return {op: 'mul', arg1: [x, y]}; };
	function add(x, y) { 
		if(x instanceof Array) return {op: 'add', arg1: x};
		return {op: 'add', arg1: [x, y]}; 
	};
	function oneminus(x) { 
		return add(1, neg(x));
	};
	function sq(x) { 
		return mul(x, x);
	};
	
	function getTransformMatrix(xfm) {
		if(xfm.transform == 'rotX') {
			return {op: 'mat', arg1: [
				[1, 0,              0,                   0],
				[0, cos(xfm.Theta), neg(sin(xfm.Theta)), 0],
				[0, sin(xfm.Theta),     cos(xfm.Theta),  0],
				[0, 0,              0,                   1],
			]};
		}
		else if(xfm.transform == 'rotY') {
			return {op: 'mat', arg1: [
				[cos(xfm.Theta),      0, sin(xfm.Theta), 0],
				[0,                   1, 0,              0],
				[neg(sin(xfm.Theta)), 0, cos(xfm.Theta), 0],
				[0,                   0, 0,              1],
			]};
		}
		else if(xfm.transform == 'rotZ') {
			return {op: 'mat', arg1: [
				[cos(xfm.Theta), neg(sin(xfm.Theta)), 0, 0],
				[sin(xfm.Theta), cos(xfm.Theta),      0, 0],
				[0,              0,                   1, 0],
				[0,              0,                   0, 1],
			]};
		}
		else if(xfm.transform == 'rotZ') {
			return {op: 'mat', arg1: [
				[cos(xfm.Theta), neg(sin(xfm.Theta)), 0, 0],
				[sin(xfm.Theta), cos(xfm.Theta),      0, 0],
				[0,              0,                   1, 0],
				[0,              0,                   0, 1],
			]};
		}
		else if(xfm.transform == 'scale') {
			return {op: 'mat', arg1: [
				[xfm.X, 0,     0,     0],
				[0,     xfm.Y, 0,     0],
				[0,     0,     xfm.Z, 0],
				[0,     0,     0,     1],
			]};
		}
		else if(xfm.transform == 'translate') {
			return {op: 'mat', arg1: [
				[1, 0, 0, xfm.X],
				[0, 1, 0, xfm.Y],
				[0, 0, 1, xfm.Z],
				[0, 0, 0, 1],
			]};
		}
		else if(xfm.transform == 'rotAxis') {
			var c = cos(xfm.Theta);
			var s = sin(xfm.Theta);
			var omc = oneminus(cos(xfm.Theta));
			return {op: 'mat', arg1: [
				[
					add(mul(omc, mul(xfm.X, xfm.X)), c), 
					add(mul(omc, mul(xfm.X, xfm.Y)), mul(s, xfm.Z)),
					add(mul(omc, mul(xfm.X, xfm.Z)), mul(neg(s), xfm.Y)),
					0
				],
				[
					add(mul(omc, mul(xfm.Y, xfm.X)), mul(neg(s), xfm.Z)), 
					add(mul(omc, mul(xfm.Y, xfm.Y)), c), 
					add(mul(omc, mul(xfm.Y, xfm.Z)), mul(s, xfm.X)), 
					0
				],
				[
					add(mul(omc, mul(xfm.Z, xfm.X)), mul(s, xfm.Y)), 
					add(mul(omc, mul(xfm.Z, xfm.Y)), mul(neg(s), xfm.X)), 
					add(mul(omc, mul(xfm.Z, xfm.Z)), c), 
					0
				],
				[0, 0, 0, 1],
			]};
		}
		
	}
	
	function grow_term(a, b) {
		var t = {op: 'term', arg1: 1.0, arg2: [] };
		
		if(typeof a == 'object' && a.op == 'neg') {
			t.arg1 = !t.arg1;
			a = a.arg1;
		}
		if(typeof b == 'object' && b.op == 'neg') {
			t.arg1 = !t.arg1;
			b = b.arg1;
		}
		
// 		if(is_num(a)) {
// 			t.rat.t += t.rat.b * Math.abs(a);
// 			t.neg = t.neg ^ (a < 0);
// 		}
		if(is_num(a)) {
			t.arg1 *= Math.abs(a);
			t.neg ^= (a < 0);
		}
		if(is_num(b)) {
			t.arg1 *= Math.abs(b);
			t.neg ^= (b < 0);
		}
		
		
		if(is_builtin(a)) {
			// temp: addit straight in
			// todo: square duplicates
			t.arg2.push(a);
		}
		if(is_builtin(b)) {
			// temp: addit straight in
			// todo: square duplicates
			t.arg2.push(b);
		}
		
		if(is_op(a, 'term')) {
			t.arg1 *= a.arg1;
			t.arg2 = t.arg2.concat(a.arg2)
		}
		if(is_op(b, 'term')) {
			t.arg1 *= b.arg1;
			t.arg2 = t.arg2.concat(b.arg2)
		}
		
		
		if(is_op(a, 'add')) { // from a simple term
			t.arg2.push(a)
		}
		if(is_op(b, 'add')) { // from a simple term
			t.arg2.push(b)
		}
		

		
		return t;
	}
	
	function is_num(xp) {
		return typeof(xp) == 'number';
	}
	function is_builtin(xp) {
		if(typeof(xp) != 'object') return false;
		if(xp.op == 'cos' || xp.op == 'sin' || xp.op == 'neg') return true;
		return false;
	}
	function is_const(xp) {
		return is_num(xp) || (is_builtin(xp) && is_const(xp.arg1)) || is_op(xp, 'uvar');
	}
	function is_simple_term(xp) {
		if(is_num(xp) || (is_builtin(xp) && is_const(xp.arg1))) return true;
		if(xp.op == 'add') {
			if(!(is_num(xp.arg1[0]) || is_num(xp.arg1[1]))) return false;
			if(!(is_builtin(xp.arg1[0]) || is_builtin(xp.arg1[1]))) return false;
			return true;
		}
	}
	function is_matrix(xp) {
		return typeof(xp) == 'object' && xp.op == 'mat';
	}
	
	function constant_fold(op, a1, a2, xp) {
		
		if(op == 'add') {
			// eliminate additions of length 1
			if(a1.length == 1) return a1[0];
			
			var m = false;
			var mc = 0;
			var cnst = 0;
			var o = [];
			
			for(var x of a1) {
				if(is_num(x)) {
					cnst += x;
					mc++;
					continue;
				}
				
				if(is_op(x, 'add')) {
					o = o.concat(x.arg1);
					m = true;
					continue;
				}
				
				o.push(x);
			}
			
			m = m || mc > 1;
			
			if(o.length == 0) return cnst;
			
			if(!m  /* && !(mc > 0 && cnst == 0)*/) return false;
			
			
			
			if(cnst != 0) o.push(cnst);
			
			
			return {op: 'add', arg1: o};
		}
		
		if(op == 'mul') {
			
			
			// eliminate additions of length 1
			if(a1.length == 1) return a1[0];
			
			// not exactly constant folding below here
			if(is_matrix(a1[0]) && is_matrix(a1[1])) {
				return mat_mul(a1[0], a1[1]);
			}
			/*
			// construct terms
			if(is_simple_term(a1[0]) && is_simple_term(a1[1])) {
				return grow_term(a1[0], a1[1]);
			}
			
			if(is_op(a1[0], 'term') && is_simple_term(a1[1])) {
				return grow_term(a1[0], a1[1]);
			}
			if(is_simple_term(a1[0]) && is_op(a1[1], 'term')) {
				return grow_term(a1[0], a1[1]);
			}
			if(is_op(a1[0], 'term') && is_op(a1[1], 'term')) {
				return grow_term(a1[0], a1[1]);
			}
			*/
			
			// collapse constants
			var m = false;
			var mc = 0;
			var cnst = 1;
			var o = [];
			
			for(var x of a1) {
				if(x == 0) {
					return 0;
				}
				
				if(is_num(x)) {
					cnst *= x;
					mc++;
					continue;
				}
				
				if(is_op(x, 'mul')) {
					o = o.concat(x.arg1);
					m = true;
					continue;
				}
				

				
				o.push(x);
			}
			
			m = m || mc > 1;
			
			if(o.length == 0) return cnst;
			if(!m) return false;
			
			if(cnst != 1) o.push(cnst);
			return {op: 'mul', arg1: o};
		}
		
		if(op == 'term') {
			if(a1 == 0) return 0;
		}
		
		if(op == 'neg') {
			if(a1 == 0) return 0;
			if(is_num(a1)) {
				return -a1;
			}
		}
		
		if(op == 'cos') {
			if(a1 == 0) return 1;
			if(a1 == 'pi') return 0;
		}
		if(op == 'sin') {
			if(a1 == 'pi') return 1;
			if(a1 == 0) return 0;
		}
		
		return false;
	}
	
	function mat_mul(aa, bb) {
		var a = aa.arg1;
		var b = bb.arg1;
		var out = [[],[],[],[]];
		
		for(r = 0; r < 4; r++) {
			for(c = 0; c < 4; c++) {
				out[c][r] = add([
					mul(a[c][0], b[0][r]), 
					mul(a[c][1], b[1][r]),
					mul(a[c][2], b[2][r]),
					mul(a[c][3], b[3][r])
				]);
			}
		}
		
		return {op: 'mat', arg1: out};
	}
	
	function terms_are_equal(a, b) {
		var aa = a.arg2.slice().map(function(xp) { return printXP(txtPrintFns, xp) }).sort().join(':');
		var bb = b.arg2.slice().map(function(xp) { return printXP(txtPrintFns, xp) }).sort().join(':');
		return aa == bb;
	}
	
	function combine_terms(op, a1, a2, xp) {
		if(op == 'add') {
			if(is_op(a1, 'term') && is_op(a2, 'term')) {
				if(terms_are_equal(a1, a2)) {
					var sum = a1.arg1 + a2.arg1;
					if(sum == 0) return 0;
					
					return {
						op: 'term',
						arg1: sum,
						arg2: a1.arg2,
					}
				}
			}
		}
		
		return false;
	}
	
	// applies the distributive property of multiplication and addition widely
	function distribute_terms(op, a1, a2, xp) {
		if(op == 'mul') {
			if(is_op(a1, 'add') && is_op(a2, 'add')) {
				
				return add([
					mul(a1.arg1, a2.arg1), 
					mul(a1.arg2, a2.arg2),
					mul(a1.arg2, a2.arg1), 
					mul(a1.arg2, a2.arg1)
				]);
			}
			
			if(is_op(a1, 'add') && is_op(a2, 'term')) {
				
				return add(mul(a1.arg1, a2), mul(a1.arg2, a2));
			}
			
			if(is_op(a1, 'term') && is_op(a2, 'add')) {
				
				return add(mul(a2.arg1, a1), mul(a2.arg2, a1));
			}
			
			if((is_num(a1) || is_builtin(a1)) && is_op(a2, 'add')) {
				return add(mul(a1, a2.arg1), mul(a1, a2.arg2));
			}
			if((is_num(a2) || is_builtin(a2)) && is_op(a1, 'add')) {
				return add(mul(a2, a1.arg1), mul(a2, a1.arg2));
			}
		}
		
		return false;
	}
	
	function optimize_op(xp, fn) {
		if(typeof(xp) != 'object') {
			return [false, xp];
		}
		if(xp instanceof Array) {
			var m = false;
			var o = xp.map(function(x) { 
				var [m1, o1] = optimize_op(x, fn);
				m = m || m1;
				return o1;
			});
			return [m, o];
		}
		
		var modified = false;
		
		if(xp.op == 'mat') {
			var o = [];
			for(var a = 0; a < 4; a++) {
				o[a] = [];
				for(var b = 0; b < 4; b++) {
					var z = optimize_op(xp.arg1[a][b], fn);
					o[a][b] = z[1];
					
					modified = modified || z[0];
				}
			}
			return [modified, {op: 'mat', arg1: o}];
		}
		
		
		var [m1, a1] = optimize_op(xp.arg1, fn);
		var [m2, a2] = optimize_op(xp.arg2, fn);
		
		var out = fn(xp.op, a1, a2, xp);
		
		if(out === false) {
			return [m1 || m2, {op: xp.op, arg1: a1, arg2: a2}];
		}
		else return [true, out];
	}
	
	// breadth-first
	function bf_optimize_op(xp, fn) {
		if(typeof(xp) != 'object') {
			return [false, xp];
		}
		if(xp instanceof Array) {
			var m = false;
			var o = xp.map(function(x) { 
				
				var out = fn(xp.op, a1, a2, fn);
				if(out === false) {
					var [m1, o1] = bf_optimize_op(x, fn);
					m = m || m1;
				}
				else {
					m = true;
					o1 = out;
				}
				return o1;
			});
			return [m, o];
		}
		
		var modified = false;
		
		if(xp.op == 'mat') {
			var o = [];
			for(var a = 0; a < 4; a++) {
				o[a] = [];
				for(var b = 0; b < 4; b++) {
					var out = fn(xp, fn);
					
					if(out === false) {
						var z = bf_optimize_op(xp.arg1[a][b], fn);
						o[a][b] = z[1];
						
						modified = modified || z[0];
					}
					else {
						modified = true;
						o[a][b] = out;
					}
					
					
				}
			}
			return [modified, {op: 'mat', arg1: o}];
		}
		
		var out = fn(xp, fn);
		
		if(out === false) {
			var [m1, a1] = bf_optimize_op(xp.arg1, fn);
			var [m2, a2] = bf_optimize_op(xp.arg2, fn);
			
			return [m1 || m2, {op: xp.op, arg1: a1, arg2: a2}];
		}
		else return [true, out];
	}
	
	
	function walk_ops(xp, fn) {
		if(typeof(xp) != 'object') {
			return;
		}
		if(xp instanceof Array) {
			xp.map(function(x) { 
				walk_ops(x, fn);
			});
			return;
		}
		
		if(xp.op == 'mat') {
			for(var a = 0; a < 4; a++) {
				for(var b = 0; b < 4; b++) {
					walk_ops(xp.arg1[a][b], fn);
				}
			}
			return;
		}
		
		walk_ops(xp.arg1, fn);
		walk_ops(xp.arg2, fn);
		
		fn(xp);
	}
	
	
	
</script>

</head>
<body>
	
	<div class="controls">
		<select class="transform-type">
			<option value="">-- Select Transformation --</option>
			<option value="rotX">Rotation about X</option>
			<option value="rotY">Rotation about Y</option>
			<option value="rotZ">Rotation about Z</option>
			<option value="rotAxis">Rotation about Axis</option>
			<option value="translate">Translation</option>
			<option value="scale">Scale</option>
		</select>
		
		<div class="rotX-options transform-option" style="display:none;">
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		<div class="rotY-options transform-option" style="display:none;">
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		<div class="rotZ-options transform-option" style="display:none;">
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		
		<div class="rotAxis-options transform-option" style="display:none;">
			<label>Axis X</label><input type="edit" name="X" value="0"></input>
			<label>Axis Y</label><input type="edit" name="Y" value="0"></input>
			<label>Axis Z</label><input type="edit" name="Z" value="0"></input>
			<label>Theta</label><input type="edit" name="Theta" value="0"></input>
		</div>
		
		<div class="translate-options transform-option" style="display:none;">
			<label>X</label><input type="edit" name="X" value="0"></input>
			<label>Y</label><input type="edit" name="Y" value="0"></input>
			<label>Z</label><input type="edit" name="Z" value="0"></input>
		</div>
		
		<div class="scale-options transform-option" style="display:none;">
			<label>X</label><input type="edit" name="X" value="0"></input>
			<label>Y</label><input type="edit" name="Y" value="0"></input>
			<label>Z</label><input type="edit" name="Z" value="0"></input>
		</div>
		
		<button name="add">Add</button>
		
	</div>
	
	<div class="chain">
		
		
	</div>
	
	<div class="output">
		<button name="solve">Solve</button>
		
		<div class="results"></div> 
		
	</div>
	
</body>
</html>
